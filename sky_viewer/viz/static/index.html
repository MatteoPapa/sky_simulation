<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Visualizer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <style>
        html,
        body,
        #map {
            height: 100%;
            margin: 0;
        }

        .legend {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: #fff;
            padding: 6px 8px;
            border-radius: 4px;
            font: 12px sans-serif;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script>
        const map = L.map("map", { preferCanvas: true }).setView([45.4642, 9.19], 12);
        const MAX_TRAIL = 200;

        L.tileLayer(
            "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
            {
                maxZoom: 19,
                attribution: "&copy; OpenStreetMap & Carto",
            }
        ).addTo(map);

        const markers = {},
            trails = {};
        let autoFitDone = false;

        function colorForAlt(a) {
            const t = Math.max(0, Math.min(1, a / 1000));
            return `rgb(${Math.floor(255 * t)},0,${Math.floor(
                255 * (1 - t)
            )})`;
        }
        function fmtTooltip(u) {
            return `${u.uav_id}<br/>alt ${u.alt.toFixed(
                0
            )}m<br/>spd ${u.speed.toFixed(1)}m/s<br/>dir ${u.dir.toFixed(
                0
            )}Â°`;
        }

        function up(u) {
            const id = u.uav_id,
                ll = [u.lat, u.lon];
            if (!markers[id]) {
                const m = L.circleMarker(ll, {
                    radius: 6,
                    weight: 2,
                    color: colorForAlt(u.alt),
                }).addTo(map);
                m.bindTooltip(fmtTooltip(u), {
                    direction: "top",
                    opacity: 0.9,
                });
                markers[id] = m;
            } else {
                markers[id].setLatLng(ll);
                markers[id].setStyle({ color: colorForAlt(u.alt) });
                const tt = markers[id].getTooltip();
                if (tt) tt.setContent(fmtTooltip(u));
            }

            if (!trails[id])
                trails[id] = {
                    pts: [],
                    line: L.polyline([], { weight: 2, opacity: 0.6 }).addTo(
                        map
                    ),
                };
            const t = trails[id];
            t.pts.push(ll);
            if (t.pts.length > MAX_TRAIL) t.pts.shift();
            t.line.setLatLngs(t.pts);

            if (!autoFitDone) {
                const group = L.featureGroup(Object.values(markers));
                map.fitBounds(group.getBounds().pad(0.2));
                autoFitDone = true;
            }
        }

        const wsProto = location.protocol === "https:" ? "wss" : "ws";
        const ws = new WebSocket(`${wsProto}://${location.host}/ws`);
        ws.onmessage = (ev) => {
            const msg = JSON.parse(ev.data);
            if (msg.type === "snapshot") {
                msg.uavs.forEach(up);
            } else if (msg.type === "update") {
                up(msg.uav);
            } else if (msg.type === "frame") {
                for (const u of msg.uavs) up(u); 
            }
        };

        setInterval(() => ws.readyState === 1 && ws.send("{}"), 15000);
    </script>
</body>

</html>